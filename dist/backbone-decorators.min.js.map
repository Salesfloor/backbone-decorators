{"version":3,"sources":["/source/backbone-decorators.js","/source/src/backbone-decorators.js","backbone-decorators.min.js"],"names":["global","factory","exports","module","require","define","amd","Decorators","_","this","on","eventName","target","name","descriptor","events","isFunction","Error","tagName","value","prototype","onModel","modelEvents","onCollection","collectionEvents","template","childView","childViewContainer","ui","_len","arguments","length","args","Array","_key","key","isObject","extend","isString","useSuper","superMethod","Object","getPrototypeOf","_len2","_key2","apply"],"mappings":"CAAC,SAAUA,EAAQC,GACI,gBAAZC,UAA0C,mBAAXC,QAAyBF,EAAQC,QAASE,QAAQ,eACtE,kBAAXC,SAAyBA,OAAOC,IAAMD,QAAQ,UAAW,cAAeJ,GAC/EA,EAASD,EAAOO,cAAkBP,EAAOQ,IAC3CC,KAAM,SAAUP,EAASM,GAAK,YCOzB,SAASE,GAAGC,GACf,MAAO,UAASC,EAAQC,EAAMC,GAI1B,GAHKF,EAAOG,SACRH,EAAOG,WAEPP,EAAEQ,WAAWJ,EAAOG,QACpB,KAAM,IAAIE,OAAM,2DAGpB,KAAKN,EACD,KAAM,IAAIM,OAAM,kDAGpB,OADAL,GAAOG,OAAOJ,GAAaE,EACpBC,GAIR,QAASI,GAAQC,GACpB,MAAO,UAAmBP,GACtBA,EAAOQ,UAAUF,QAAUC,GAQ5B,QAASE,GAAQV,GACpB,MAAO,UAASC,EAAQC,EAAMC,GAI1B,GAHKF,EAAOU,cACRV,EAAOU,gBAEPd,EAAEQ,WAAWJ,EAAOU,aACpB,KAAM,IAAIL,OAAM,oEAGpB,KAAKN,EACD,KAAM,IAAIM,OAAM,uDAGpB,OADAL,GAAOU,YAAYX,GAAaE,EACzBC,GAIR,QAASS,GAAaZ,GACzB,MAAO,UAASC,EAAQC,EAAMC,GAI1B,GAHKF,EAAOY,mBACRZ,EAAOY,qBAEPhB,EAAEQ,WAAWJ,EAAOY,kBACpB,KAAM,IAAIP,OAAM,8EAGpB,KAAKN,EACD,KAAM,IAAIM,OAAM,4DAGpB,OADAL,GAAOY,iBAAiBb,GAAaE,EAC9BC,GAIR,QAASW,GAASN,GACrB,MAAO,UAAmBP,GACtBA,EAAOQ,UAAUK,SAAWN,GAI7B,QAASO,GAAUP,GACtB,MAAO,UAAmBP,GACtBA,EAAOQ,UAAUM,UAAYP,GAI9B,QAASQ,GAAmBR,GAC/B,MAAO,UAAmBP,GACtBA,EAAOQ,UAAUO,mBAAqBR,GAIvC,QAASS,KCMR,IAAK,GAAIC,GAAOC,UAAUC,ODNZC,EAAAC,MAAAJ,GAAAK,EAAA,EAAAL,EAAAK,EAAAA,IAAAF,EAAAE,GAAAJ,UAAAI,EAClB,OAAO,UAAmBtB,GACtB,GAAIgB,GAAKhB,EAAOQ,UAAUQ,OACrBO,EAAcH,EAAA,GAATb,EAASa,EAAA,EACnB,IAAIxB,EAAE4B,SAASD,GACX3B,EAAE6B,OAAOT,EAAII,EAAK,QACf,CAAA,IAAIxB,EAAE8B,SAASH,KAAQ3B,EAAE8B,SAASnB,GAGrC,KAAM,IAAIF,OAAM,yFAFhBW,GAAGO,GAAOhB,EAIdP,EAAOQ,UAAUQ,GAAKA,GAMvB,QAASW,GAAS3B,EAAQC,EAAMC,GACnC,GAAI0B,GAAcC,OAAOC,eAAe9B,GAAQC,EAChD,KAAIL,EAAEQ,WAAWwB,GAKb,KAAM,IAAIvB,OAAM,4GAEpB,OANIH,GAAWK,MAAQ,WCYX,IAAK,GAAIwB,GAAQb,UAAUC,ODZJC,EAAAC,MAAAU,GAAAC,EAAA,EAAAD,EAAAC,EAAAA,IAAAZ,EAAAY,GAAAd,UAAAc,EAC3BJ,GAAYK,MAAMpC,KAAMuB,IAKzBlB,ED9GPN,EAAK,WAAaA,GAAIA,EAAE,WAAaA,ECNzCN,EAAAQ,GAAAA,EAAAR,EAAAgB,QAAAA,EAAAhB,EAAAmB,QAAAA,EAAAnB,EAAAqB,aAAAA,EAAArB,EAAAuB,SAAAA,EAAAvB,EAAAwB,UAAAA,EAAAxB,EAAAyB,mBAAAA,EAAAzB,EAAA0B,GAAAA,EAAA1B,EAAAqC,SAAAA","file":"backbone-decorators.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('underscore')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'underscore'], factory) :\n    factory((global.Decorators = {}), global._)\n}(this, function (exports, _) { 'use strict';\n\n    _ = ('default' in _ ? _['default'] : _);\n\n    /* Ideally we'd want to just pass these exports through directly\n     * but Babel complains about nesting exports, so we attach them\n     * to a namespace\n     */\n\n    // Backbone Decorators\n\n    // Views\n\n    function on(eventName) {\n        return function(target, name, descriptor) {\n            if (!target.events) {\n                target.events = {};\n            }\n            if (_.isFunction(target.events)) {\n                throw new Error('The on decorator is not compatible with an events method');\n                return;\n            }\n            if (!eventName) {\n                throw new Error('The on decorator requires an eventName argument');\n            }\n            target.events[eventName] = name;\n            return descriptor;\n        };\n    }\n\n    function tagName(value) {\n        return function decorator(target) {\n            target.prototype.tagName = value;\n        };\n    }\n\n    // Marionette Decorators\n\n    // Views\n\n    function onModel(eventName) {\n        return function(target, name, descriptor) {\n            if (!target.modelEvents) {\n                target.modelEvents = {};\n            }\n            if (_.isFunction(target.modelEvents)) {\n                throw new Error('The onModel decorator is not compatible with a modelEvents method');\n                return;\n            }\n            if (!eventName) {\n                throw new Error('The onModel decorator requires an eventName argument');\n            }\n            target.modelEvents[eventName] = name;\n            return descriptor;\n        };\n    }\n\n    function onCollection(eventName) {\n        return function(target, name, descriptor) {\n            if (!target.collectionEvents) {\n                target.collectionEvents = {};\n            }\n            if (_.isFunction(target.collectionEvents)) {\n                throw new Error('The onCollection decorator is not compatible with a collectionEvents method');\n                return;\n            }\n            if (!eventName) {\n                throw new Error('The onCollection decorator requires an eventName argument');\n            }\n            target.collectionEvents[eventName] = name;\n            return descriptor;\n        };\n    }\n\n    function template(value) {\n        return function decorator(target) {\n            target.prototype.template = value;\n        };\n    }\n\n    function childView(value) {\n        return function decorator(target) {\n            target.prototype.childView = value;\n        };\n    }\n\n    function childViewContainer(value) {\n        return function decorator(target) {\n            target.prototype.childViewContainer = value;\n        };\n    }\n\n    function ui(...args) {\n        return function decorator(target) {\n            let ui = target.prototype.ui || {};\n            let [key, value] = args;\n            if (_.isObject(key)) {\n                _.extend(ui, args[0]);\n            } else if (_.isString(key) && _.isString(value)) {\n                ui[key] = value;\n            } else {\n                throw new Error('The ui decorator takes either a single object as an argument or a key and value string');\n            }\n            target.prototype.ui = ui;\n        };\n    }\n\n    // Utility Decorators\n\n    function useSuper(target, name, descriptor) {\n        let superMethod = Object.getPrototypeOf(target)[name];\n        if (_.isFunction(superMethod)) {\n            descriptor.value = function(...args) {\n                superMethod.apply(this, args);\n            };\n        } else {\n            throw new Error('The useSuper method requires the parent class to implement this function somewhere on its prototype chain');\n        }\n        return descriptor;\n    }\n\n    exports.on = on;\n    exports.tagName = tagName;\n    exports.onModel = onModel;\n    exports.onCollection = onCollection;\n    exports.template = template;\n    exports.childView = childView;\n    exports.childViewContainer = childViewContainer;\n    exports.ui = ui;\n    exports.useSuper = useSuper;\n\n}));\n","import _ from 'underscore';\n\n/* Ideally we'd want to just pass these exports through directly\n * but Babel complains about nesting exports, so we attach them\n * to a namespace\n */\n\n// Backbone Decorators\n\n// Views\n\nexport function on(eventName) {\n    return function(target, name, descriptor) {\n        if (!target.events) {\n            target.events = {};\n        }\n        if (_.isFunction(target.events)) {\n            throw new Error('The on decorator is not compatible with an events method');\n            return;\n        }\n        if (!eventName) {\n            throw new Error('The on decorator requires an eventName argument');\n        }\n        target.events[eventName] = name;\n        return descriptor;\n    };\n}\n\nexport function tagName(value) {\n    return function decorator(target) {\n        target.prototype.tagName = value;\n    };\n}\n\n// Marionette Decorators\n\n// Views\n\nexport function onModel(eventName) {\n    return function(target, name, descriptor) {\n        if (!target.modelEvents) {\n            target.modelEvents = {};\n        }\n        if (_.isFunction(target.modelEvents)) {\n            throw new Error('The onModel decorator is not compatible with a modelEvents method');\n            return;\n        }\n        if (!eventName) {\n            throw new Error('The onModel decorator requires an eventName argument');\n        }\n        target.modelEvents[eventName] = name;\n        return descriptor;\n    };\n}\n\nexport function onCollection(eventName) {\n    return function(target, name, descriptor) {\n        if (!target.collectionEvents) {\n            target.collectionEvents = {};\n        }\n        if (_.isFunction(target.collectionEvents)) {\n            throw new Error('The onCollection decorator is not compatible with a collectionEvents method');\n            return;\n        }\n        if (!eventName) {\n            throw new Error('The onCollection decorator requires an eventName argument');\n        }\n        target.collectionEvents[eventName] = name;\n        return descriptor;\n    };\n}\n\nexport function template(value) {\n    return function decorator(target) {\n        target.prototype.template = value;\n    };\n}\n\nexport function childView(value) {\n    return function decorator(target) {\n        target.prototype.childView = value;\n    };\n}\n\nexport function childViewContainer(value) {\n    return function decorator(target) {\n        target.prototype.childViewContainer = value;\n    };\n}\n\nexport function ui(...args) {\n    return function decorator(target) {\n        let ui = target.prototype.ui || {};\n        let [key, value] = args;\n        if (_.isObject(key)) {\n            _.extend(ui, args[0]);\n        } else if (_.isString(key) && _.isString(value)) {\n            ui[key] = value;\n        } else {\n            throw new Error('The ui decorator takes either a single object as an argument or a key and value string');\n        }\n        target.prototype.ui = ui;\n    };\n}\n\n// Utility Decorators\n\nexport function useSuper(target, name, descriptor) {\n    let superMethod = Object.getPrototypeOf(target)[name];\n    if (_.isFunction(superMethod)) {\n        descriptor.value = function(...args) {\n            superMethod.apply(this, args);\n        };\n    } else {\n        throw new Error('The useSuper method requires the parent class to implement this function somewhere on its prototype chain');\n    }\n    return descriptor;\n}\n",null],"sourceRoot":"/source/"}